{
  "hash": "c30a51c49eda9dc05e41a6abaca79868",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  revealjs:\n    css: style.css\n    theme: simple\n    slide-number: true\n    preview-links: auto\n    footer: \"Source code for these slides can be found [on GitHub](https://github.com/IndrajeetPatil/second-hardest-cs-thing/){target='_blank'}.\"\n#   pdf: \n#     title: \"Dealing with the Second Hardest Thing in Computer Science\"\n#     subtitle: \"Thoughts on naming things for software development\"\n# author: \"Indrajeet Patil\"\n#affiliation: \nexecute:\n  echo: true\n  eval: false\nkeywords: [\"naming\", \"software-engineering\", \"computer-science\", \"software-development\"]\nlicense: \"CC0 1.0 Universal\"\n---\n\n\n\n\n\n## Dealing with the Second Hardest Thing in Computer Science {style=\"margin-top: 2em; margin-bottom: 1em;\"}\n\n<!-- Don't render this file locally Run `renderer.R` script instead. -->\n\n::: {style=\"margin-top: 1em; margin-bottom: 1em; font-size: 1em\"}\n\nIndrajeet Patil\n\n![](media/cat.png){.absolute width=\"500\" height=\"350\" right=\"40\" top=\"100\"}\n\n:::\n\n# \"There are only two hard things in Computer Science: cache invalidation and naming things.\" \n\\- Phil Karlton\n\n\n# \n\nThe following advice on naming applies to all kinds of programming entities (variables, functions, packages, classes, etc.) and is **language-agnostic**.\n\n#\n\n::: {.callout-important}\n\n## *Principle*: **Names are a form of abstraction**\n\n\"[T]he best names are those that focus attention on what is most important about the underlying entity, while omitting details that are less important.\"\n\n\\- John Ousterhout\n\n:::\n\n. . .\n\n::: {.callout-tip}\n\n### *Importance*: **Names are at the core of software design** \n\nIf you can't find a name that provides the right abstraction for the underlying entity, it is possible that the design isn't clear.\n\n:::\n\n. . .\n\n::: {.callout-note}\n\n## *Properties*: **Good names are precise and consistent**\n\nIf a name is good, it is difficult to miss out on critical information about the entity or to misunderstand what it represents.\n\n:::\n\n# \"The beginning of wisdom is to call things by their proper name.\" \n\\- Confucius\n\n## Good names are a form of documentation {.smaller}\n\nHow good a name is can be assessed by how detailed the accompanying comment needs to be.\n\n. . .\n\nE.g., the function and parameter are named poorly here, and so comments need to do all the heavy lifting:\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// function to convert temperature from Fahrenheit to Celsius scale\n// temp is the temperature in Fahrenheit\ndouble unitConverter(double temp)\n```\n:::\n\n\n\n. . .\n\nContrast it with this:\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\ndouble fahrenheitToCelsius(double tempFahrenheit)\n```\n:::\n\n\n\nNo need for a comment here!\n\n. . .\n\n::: {.callout-tip}\n\n**Good names rarely require readers to read the documentation to understand what they represent.**\n\n:::\n\n## Generic names should follow conventions {.smaller}\n\nUsing generic names can improve code readability, but *only if* language or domain customs are followed.\n\n. . .\n\nExamples:\n\n- In a nested loop, using `j` for outer and `i` for inner loop index is confusing!\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n  for (let j = 0; j < arr.length; j++) {\n    for (let i = 0; i < arr[j].length; i++) {\n```\n:::\n\n\n\n- `tmp` shouldn't be used to store objects that are not temporary\n- `retVal` shouldn't be used for objects not returned from a function\n\n. . .\n\n::: {.callout-tip}\n\n**Don't violate reader assumptions about what generic names represent.**\n\n:::\n\n## Alternatives to generic names {.smaller}\n\nIf a loop is longer than a few lines, use more meaningful loop variable names than `i`, `j`, and `k` because you will quickly lose track of what they mean.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# abstruse\nexam_score[i][j]\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# crystal clear\nexam_score[school][student]\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\n<br>\n\nAll variables are temporary in some sense. Calling one `tmp` is inviting carelessness.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# generic name\nif (right < left) {\n  tmp   = right\n  right = left\n  left  = tmp\n}\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# more descriptive\nif (right < left) {\n  old_right = right\n  right     = left\n  left      = old_right\n}\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\n<br>\n\n::: {.callout-tip}\n\n**Even when you *think* you need generic names, you are better off using descriptive names.**\n\n:::\n\n## Names should be consistent {.smaller}\n\nConsistent names **reduce cognitive burden** because if the reader encounters a name in one context, they can safely reuse that knowledge in another context.\n\n. . .\n\nFor example, these names are inconsistent since the reader can't safely assume that the name *size* means the same thing throughout the program.\n\n:::: {.columns}\n\n::: {.column width='70%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// context-1: `size` stands for number of memory bytes\n{\n  size = sizeof(x);\n}\n\n// context-2: `size` stands for number of elements\n{\n  size = strlen(a);\n}\n```\n:::\n\n\n\n:::\n\n::: {.column width='30%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// context-1:\n{\n  size = sizeof(x);\n}\n\n// context-2:\n{\n  length = strlen(a);\n}\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\n::: {.callout-tip}\n\n**Allow users to make safe assumptions about what the names represent across different scopes/contexts.**\n\n:::\n\n## {.smaller}\n\n### Unnecessary details in names should be removed...\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# okay\nconvert_to_string()\nfileObject\nstrName # Hungarian notation\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# better\nto_string()\nfile\nname\n```\n:::\n\n\n\n:::\n\n::::\n\n:::{.callout-note}\n\n## Avoid redundancy\n\n- In type names, avoid using *class*, *data*, *object*, and *type* (e.g. bad: `classShape`, good: `Shape`)\n- In function names, avoid using *be*, *do*, *perform*, etc. (e.g. bad: `doAddition()`, good: `add()`)\n\n:::\n\n### **but** important details should be kept!\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# okay\nchild_height\npassword\nid\naddress\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# better\nchild_height_cm\nplaintext_password\nhex_id\nip_address\n```\n:::\n\n\n\n:::\n\n::::\n\n::: {.callout-tip}\n\n**If some information is critical to know, it should be part of the name.**\n\n:::\n\n## Names should utilize the context {.smaller}\n\nWhen naming, avoid redundant words by exploiting the context.\n\nE.g. if you are defining a class, its methods and variables will be read in that context.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# okay\nRouter.run_router()\nFileHandler.close_file()\nBeerShelf.beer_count\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# better\nRouter.run()\nFileHandler.close()\nBeerShelf.count\n```\n:::\n\n\n\n:::\n\n::::\n\nBut, if doing so imposes ambiguity, then you can of course tolerate some redundancy.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# bad\nMediaPlayer.play()\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n# better\nMediaPlayer.play_audio()\nMediaPlayer.play_video()\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\n::: {.callout-tip}\n\n**Shorten names with the help of context.**\n\n:::\n\n## Names should be precise but not *too* long {.smaller}\n\nHow precise (and thus long) the name should be is a **subjective decision**, but keep in mind that long names can obscure the visual structure of a program.\n\n. . .\n\nYou can typically find a middle ground between too short and too long names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# not ideal - too imprecise\nd\n\n# okay - can use more precision\ndays\n\n# good - middle ground\ndays_since_last_accident\n\n# not ideal - unnecessarily precise\ndays_since_last_accident_floor_4_lab_23\n\n...\n```\n:::\n\n\n\n. . .\n\n::: {.callout-tip}\n\n**Don't go too far with making names precise.**\n\n:::\n\n## Names should be difficult to misinterpret {.smaller}\n\nTry your best to misinterpret candidate names and see if you succeed.\n\n. . .\n\nE.g., here is a GUI text editor class method to get position of a character:\n\n\n\n::: {.cell}\n\n```{.c .cell-code}\nstd::tuple<int, int> getCharPosition(int x, int y)\n```\n:::\n\n\n\n. . .\n\nHow I interpret: *\"`x` and `y` refer to pixel positions for a character.\"*\n\n. . .\n\nIn reality: *\"`x` and `y` refer to line of text and character position in that line.\"*\n\n. . .\n\nYou can avoid such misinterpretation with better names:\n\n\n\n::: {.cell}\n\n```{.c .cell-code}\nstd::tuple<int, int> getCharPosition(int lineIndex, int charIndex)\n```\n:::\n\n\n\n. . .\n\n::: {.callout-tip}\n\n**Precise and unambiguous names leave little room for misconstrual.**\n\n:::\n\n## Names should be distinguishable {.smaller}\n\nNames that are too similar make great candidates for mistaken identity.\n\n. . .\n\nE.g. `nn` and `nnn` are easy to be confused and such confusion can lead to painful bugs.\n\n:::: {.columns}\n\n::: {.column width='40%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// bad\nlet n   = x;\nlet nn  = x ** 2;\nlet nnn = x ** 3;\n```\n:::\n\n\n\n:::\n\n::: {.column width='60%'}\n\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// good\nlet n       = x;\nlet nSquare = x ** 2;\nlet nCube   = x ** 3;\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\n::: {.callout-tip}\n\n**Any pair of names should be difficult to be mistaken for each other.**\n\n:::\n\n\n## Names should be easy to search {.smaller}\n\nWhile naming, always ask yourself how easy it would be to find and update the name.\n\n. . .\n\nE.g., this function uses `a` and `f` parameters to represent an array and a function.\n\n:::: {.columns}\n\n::: {.column width='40%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# bad\narrayMap <- function(a, f) {\n  ...\n}\n```\n:::\n\n\n\n:::\n\n::: {.column width='60%'}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# good\narrayMap <- function(arr, fun) {\n  ...\n}\n```\n:::\n\n\n\n:::\n\n::::\n\nIf needed, it wouldn't be easy either to search for and/or to rename these parameters in the codebase because searching for `a` or `f` would flag **all** *a*s and *f*s (**a**pi, **f**ile, etc.).\n\nInstead, if more descriptive identifiers are used, both search and replace operations will be straightforward.\n\n. . .\n\n::: {.callout-tip}\n\n**Choose names that can be searched and, if needed, replaced.**\n\n:::\n\n## Names should honour the conventions {.smaller}\n\nThe names should respect the conventions adopted in a given project, organization, programming language, domain of knowledge, etc.\n\n. . .\n\nFor example, C++ convention is to use PascalCase for class names and lowerCamel case for variables. \n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// non-conventional\nclass playerEntity\n{\n  public:\n    std::string HairColor;\n};\n```\n:::\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\n// conventional\nclass PlayerEntity\n{\n  public:\n    std::string hairColor;\n};\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\n::: {.callout-tip}\n\n**Don't break conventions unless other guidelines require overriding them for consistency.**\n\n:::\n\n<!-- ## Names should clarify dependencies {.smaller} -->\n\n<!-- If a set of functions have dependencies (because they share the same data, e.g.), their names should clarify this dependence. -->\n\n<!-- . . .  -->\n\n<!-- E.g., computing annual revenues involves computing quarterly revenues, which in turn requires computing monthly revenues. -->\n\n<!-- ```{r} -->\n<!-- revenues <- compute_revenues_data(raw_revenues_data) -->\n<!-- revenues <- compute_monthly_revenues(revenues) -->\n<!-- revenues <- compute_quarterly_revenues(revenues) -->\n<!-- revenues <- compute_annual_revenues(revenues) -->\n<!-- ``` -->\n\n<!-- Each of the function names makes clear the order in which they need to be run. -->\n\n## Name Booleans with extra care {.smaller}\n\nNames for Boolean variables or functions should make clear what true and false mean. This can be done using prefixes (**is**, **has**, **can**, etc.).\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# not great\nif (child) {\n  if (parentSupervision) {\n    watchHorrorMovie <- TRUE\n  }\n}\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# better\nif (isChild) {\n  if (hasParentSupervision) {\n    canWatchHorrorMovie <- TRUE\n  }\n}\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\nIn general, use positive terms for Booleans since they are easier to process.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# double negation - difficult\nis_firewall_disabled <- FALSE\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# better\nis_firewall_enabled <- TRUE\n```\n:::\n\n\n\n:::\n\nBut if the variable is only ever used in its false version (e.g. `is_volcano_inactive`), the negative version can be easier to work with.\n\n::::\n\n. . .\n\n::: {.callout-tip}\n\n**Boolean variable names should convey what true or false values represent.**\n\n:::\n\n## Avoid implementation details in names {.smaller}\n\nNames with implementation details (e.g., data structure) have high maintenance cost. When implementation changes, identifiers need to change as well.\n\n. . .\n\nE.g., consider variables that store data in different data structures or cloud services.:\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# bad\nbonuses_pd  # pandas DataFrame\nbonuses_pl  # polars DataFrame\n\naws_s3_url  # AWS bucket\ngcp_url     # GCP bucket\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# good\nbonuses    # data structure independent\n\nbucket_url # cloud service independent\n```\n:::\n\n\n\n:::\n\nNote that good names don't need to change even if the implementation details change.\n\n::::\n\n. . . \n\n::: {.callout-tip}\n\n**Names should be independent of implementation details.**\n\n:::\n\n## Find correct abstraction level for names {.smaller}\n\nDon't select names at a lower level of abstraction just because that's where the corresponding objects were defined.\n\nE.g., if you are writing a function to compute difference between before and after values, the parameter names should reflect the higher-level concept.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# bad\nfunction(value_before, value_after) { ... }\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# good\nfunction(value1, value2) { ... }\n```\n:::\n\n\n\n:::\n\n::::\n\nNote that the good parameter names clarify the general purpose of the function, which is to compute difference between *any* two values, not just before and after values.\n\n. . .\n\n::: {.callout-tip}\n\n**Choose names that reflect the higher-level concept.**\n\n:::\n\n## Test function names should be detailed {.smaller}\n\nIf unit testing in a given programming language requires writing test functions, choose names that describe the details of the test.\n\nThe test function names should effectively act as a comment.\n\n:::: {.columns}\n\n::: {.column width='30%'}\n\n```{.python}\n# bad\ndef test1\ndef my_test\ndef retrieve_commands\ndef serialize_success\n```\n\n\n:::\n\n::: {.column width='70%'}\n\n```{.python}\n# good\ndef test_array\ndef test_multilinear_model\ndef all_the_saved_commands_should_be_retrieved\ndef should_serialize_the_formula_cache_if_required\n```\n\n:::\n\n::::\n\n:::{.callout-note}\n\nDon't hesitate to choose lengthy names for **test** functions.\n\nUnlike regular functions, long names are less problematic for test functions because\n\n- they are not visible or accessible to the users\n- they are not called repeatedly throughout the codebase \n\n:::\n\n## Names should be kept up-to-date {.smaller}\n\nTo resist software entropy, not only should you name entities properly, but you should also update them. Otherwise, names will become something worse than meaningless or confusing: **misleading**.\n\n. . .\n\nFor example, let's say your class has the `$getMeans()` method.\n\n- In its initial implementation, it used to return *precomputed* mean values. \n- In its current implementation, it *computes* the mean values on the fly. \n\nTherefore, it is misleading to continue to call it a getter method, and it should be renamed to (e.g.) `$computeMeans()`.\n\n. . .\n\n::: {.callout-tip}\n\n**Keep an eye out for API changes that make names misleading.**\n\n:::\n\n## Names should be pronounceable {.smaller}\n\nThis is probably the weakest of the requirements, but one can't deny the ease of communication when names are pronounceable.\n\n. . .\n\nIf you are writing a function to generate a time-stamp, discussing the following function verbally would be challenging.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate year month date hour minute second\ngenymdhms()\n```\n:::\n\n\n\nThis is a much better (and pronounceable) alternative:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerateTimeStamp()\n```\n:::\n\n\n\n. . .\n\nAdditionally, avoid naming separate entities with homonyms.\n\nDiscussing entities named `waste` and `waist` is inevitably going to lead to confusion.\n\n## Use consistent lexicon in a project {.smaller}\n\nOnce you settle down on a mapping from an abstraction to a name, use it consistently *throughout the code base*.\n\n. . .\n\nE.g., two similar methods here have different names across `R6` classes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCreditCardAccount$new()$retrieve_expenditure()\nDebitCardAccount$new()$fetch_expenditure()\n```\n:::\n\n\n\nBoth of these methods should either be named `$retrieve_expenditure()` or `$fetch_expenditure()`.\n\n. . .\n\n::: {.callout-tip}\n\n**Consistency of naming conventions should be respected at both narrow and broad scopes.**\n\n:::\n\n## Choose informative naming conventions {.smaller}\n\nHaving different name formats for different entities **acts like syntax highlighting**. That is, a name not only represents an entity but also provides hints about its nature.\n\n:::{.callout-note}\n\n## Example of coding standards adopted in [OSP organization](https://github.com/Open-Systems-Pharmacology/Suite/blob/develop/CODING_STANDARDS.md){target=\"_blank\"}\n\n- Use all ALL_CAPS for constant variables (`public const double PI = 3.14;`)\n- Prefix private/protected member variable with `_` (`private int _currentDebt`)\n- Use Pascal Casing for class names (`public class GlobalAccounting`)\n- Use Pascal Casing for public and protected method name (`public void GetRevenues()`)\n- Use Camel Casing for private method name (`private int balanceBooks()`)\n- ...\n\n:::\n\n. . .\n\n::: {.callout-tip}\n\n**Following *a* convention consistently is more important than *which* convention you adopt.**\n\n:::\n\n## ICYMI: Available casing conventions {.smaller}\n\nThere are various casing conventions used for software development.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](media/horst_cases.jpeg){fig-align='center' fig-alt='An illustration showing casing conventions used for software development.'}\n:::\n:::\n\n\n\n:::{style=\"text-align: center; font-size: 0.9rem;\"}\n\nIllustration (CC-BY) by [Allison Horst](https://allisonhorst.com/){target=\"_blank\"}\n\n:::\n\n# A sundry of don'ts\n\nYou won't have to remember any of these rules if you follow the following principle:\n\n\"Names must be readable for the *reader*, not *writer*, of code.\"\n\n## {.smaller}\n\n- **Don't use pop-culture references in names.** Not everyone can be expected to be familiar with them. E.g. `female_birdsong_recording` is a better variable name than `thats_what_she_said`.\n\n. . .\n\n- **Don't use slang.** You can't assume current or future developers to be familiar with them. E.g. `exit()` is better than `hit_the_road()`.\n\n. . .\n\n- **Avoid unintended meanings.** Do your due diligence to check dictionaries (especially [Urban dictionary](https://www.urbandictionary.com/){target=\"_blank\"}!) if the word has unintended meaning. E.g. `cumulative_sum()` is a better function name than [`cumsum()`](https://rdrr.io/r/base/cumsum.html){target=\"_blank\"}.\n\n. . .\n\n- **Avoid imprecise opposites**, since they can be [confusing](https://github.com/pomber/awesome-word-pairs). E.g. parameter combination `begin`/`last` is worse than either `begin`/`end` or `first`/`last`.\n\n## {.smaller}\n\n- **Don't use inconsistent abbreviations.** E.g. instead of using `numColumns` (*number* of columns) in one function and `noRows` (*number* of rows) in another, choose one abbreviation as a prefix and use it consistently.\n\n. . .\n\n- **Don't use hard-to-distinguish character pairs in names** (e.g., `l` and `I`, `O` and `0`, etc.). With certain fonts, it can be hard to distinguish `firstl` from `firstI`.\n\n. . .\n\n- **Don't misspell to save a few characters.** Remembering spelling is difficult, and remembering *correct misspelling* even more so. E.g. don't use `hilite` instead of `highlight`. The benefit is not worth the cost here.\n\n. . .\n\n- **Don't use commonly misspelled words in English.** Using such names for variables can, at minimum, slow you down, or, at worst, increase the possibility of making an error. E.g. is it `accumulate`, `accummulate`, `acumulate`, or `acummulate`?!\n\n## {.smaller}\n\n- **Don't use misleading abbreviations.** E.g., in R, `na.rm` parameter removes (`rm`) missing values (`NA`). Using it to mean \"remove (`rm`) non-authorized (`NA`) entries\" for a function parameter will be misleading.\n\n. . .\n\n- **Don't allow multiple English standards.** E.g. using both American and British English standards would have you constantly guessing if the variable is named (e.g.) `centre` or `center`. Adopt one standard and stick to it.\n\n. . .\n\n- **Don't use similar names for entities with different meanings.** E.g. `patientRecs` and `patientReps` are easily confused because they are so similar. There should be at least two-letter difference: `patientRecords` and `patientReports`.\n\n# Case studies\n\nLooking at names in the wild that violate presented guidelines.\n\nThis is **not** to be taken as criticisms, but as learning opportunities to drive home the importance of these guidelines.\n\n## Violation: Breaking (domain) conventions {.smaller}\n\nR is a programming language for statistical computing, and function names can be expected to respect the domain conventions.\n\n. . .\n\nStatistical distributions can be characterized by centrality measures, and R has functions with names that wouldn't surprise you, **except one**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4)\nmean(x)   # expected output\nmedian(x) # expected output\nmode(x)   # unexpected output!\n```\n:::\n\n\n\nThe `mode()` function actually returns the storage mode of an R object!\n\n. . .\n\nThis function could have been named (e.g.) `storageMode()`, which is more precise and doesn't break domain-specific expectations.\n\n## Violation: Generic name {.smaller}\n\nThe parameter `N` in `std::array` [definition](https://en.cppreference.com/w/cpp/container/array){target=\"_blank\"} is too generic.\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\ntemplate<\n    class T,\n    std::size_t N \n> struct array;\n```\n:::\n\n\n\n. . .\n\n`size` is a bit better but still leaves room for misunderstanding:\n\n> \"Does it mean length or memory bytes?\"\n\n. . .\n\nHere is an alternative parameter name:\n\n\n\n::: {.cell}\n\n```{.js .cell-code}\ntemplate<\n    class T,\n    std::size_t numberOfElements\n> struct array;\n```\n:::\n\n\n\n`numberOfElements` is more precise and unmistakable.\n\n## Violation: Inconsistency in naming {.smaller}\n\n*ggplot2* is a [plotting framework](https://ggplot2.tidyverse.org/){target=\"_blank\"} in R, and supports both **British** and **American** English spelling standards. But does it do so *consistently*?\n\n. . .\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n**Function names**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# works\nguide_colorbar(...)\n\n# this works as well!\nguide_colourbar(...)\n```\n:::\n\n\n\n:::\n\n::: {.column width='50%'}\n\n**Function parameters**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# works\naes(color = ...)\n\n# this works as well!\naes(colour = ...)\n```\n:::\n\n\n\n:::\n\n::::\n\n. . .\n\nA user now believes that both spelling standards for function names *and* parameters are supported. And, since they prefer American spellings, they do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nguide_colorbar(ticks.color = \"black\")\n```\n:::\n\n\n\n. . .\n\n**That won't work!** Both functions support **only** the British spelling of parameters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nguide_colourbar(ticks.colour = \"black\")\nguide_colorbar(ticks.colour = \"black\")\n```\n:::\n\n\n\nThis is **inconsistent** and **violates the user's mental model** about naming schema.\n\n## Violation: Room for misunderstanding {.smaller}\n\nIn Python, [`filter()`](https://www.w3schools.com/python/ref_func_filter.asp){target=\"_blank\"} can be used to apply a function to an iterable.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist(filter(lambda x: x > 0, [-1, 1]))\n```\n:::\n\n\n\n. . .\n\nBut `filter` is an ambiguous word. It could mean either of these:\n\n- to pick out elements that pass a condition (what *remains after filtering*)\n- to pick out elements that need to be removed (what *is filtered out*)\n\nIf you've never used this function before, could you predict if it returns `1` or `-1`?\n\n. . .\n\nIt returns `1`, so the intent is to pick out the elements that pass the condition. <br>\nIn this case, **`keep()`** would be a better name.\n\nHad the intent been to find elements to remove, **`discard()`** would be a better name.\n\n# etc.\n\nIt is easy to find such violations. \n\nBut, whenever you encounter one, make it a personal exercise to come up with a better name.\n\n# Naming and good design\n\nDeep dive into benefits of thoughtful naming for an entity at the heart of all software:\n***function***\n\n## Following Unix philosophy {.smaller}\n\nUnix philosophy specifies the golden rule for writing good a function: <br>\n_\"Do One Thing And Do It Well.\"_\n\nFinding a descriptive name for a function can inform us if we are following this rule.\n\n. . .\n\nConsider a function to extract a table of regression estimates for a statistical model. \nFor convenience, it also allows sorting the table by estimate.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n:::{.callout-caution}\n\n## Naming is hard\n\nTrying to find a name highlights that the function is doing more than one thing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`???` <- function(model, sort = \"asc\") {\n  # code to extract estimates from model\n  ...\n  # code to sort table\n  ...\n}\n```\n:::\n\n\n\n:::\n\n:::\n\n::: {.column width='50%'}\n\n:::{.callout-tip}\n\n## Naming is easy\n\nThese individual functions are easier to read, understand, and test.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextract_estimates <- function(model) {\n  # code to extract estimates from model\n  ...\n}\n\nsort_estimates <- function(table, sort = \"asc\") {\n  # code to sort table\n  ...\n}\n```\n:::\n\n\n\n:::\n\n:::\n\n::::\n\n## Function parameter names {.smaller}\n\nWhen it comes to writing a good function, finding a good name for a parameter can also reveal design problems.\n\nE.g. a boolean or flag parameter name means function is doing more than one thing.\n\n. . .\n\nConsider a function that converts Markdown or HTML documents to PDF.\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n:::{.callout-caution}\n\n## Boolean parameter name\n\nDoing more than one thing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_to_pdf <- function(file, is_markdown = FALSE) {\n  if (is_markdown) {\n    # code to convert Markdown to PDF\n    ...\n  }\n\n  if (!is_markdown) {\n    # code to convert HTML to PDF\n    ...\n  }\n}\n```\n:::\n\n\n\n:::\n\n:::\n\n::: {.column width='50%'}\n\n:::{.callout-tip}\n\n## Non-boolean parameter name\n\nDoing one thing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_md_to_pdf <- function(file) {\n  # code to convert Markdown to PDF\n  ...\n}\n\nconvert_html_to_pdf <- function(file) {\n  # code to convert HTML to PDF\n  ...\n}\n```\n:::\n\n\n\n:::\n\n:::\n\n::::\n\n# \"In your name I will hope, for your name is good.\"\n\\- Psalms 52:9\n\n# Benefits of good names\n\n## *\"What's in a name?\"* Well, everything! {.smaller}\n\n. . .\n\n- Intent-revealing names make the **code easier to read**.\n\n. . .\n\n- Trying to find good names forces you to detach from the problem-solving mindset and to **focus on the bigger picture** that motivates this change. This is critical for thoughtful software design.\n\n. . .\n\n- Searching for precise names requires clarity, and seeking such clarity **improves your own understanding** of the code.\n\n. . .\n\n- Naming precisely and consistently **reduces ambiguities and misunderstandings**, which in turn reduces the possibility of bugs.\n\n. . .\n\n- Good names **reduce the need for documentation**.\n\n. . .\n\n- Consistent naming **reduces cognitive overload** for the developers and makes the code more maintainable.\n\n# Challenges\n\nInitially, you may struggle to find good names and settle down for the first serviceable name that pops into your head. \n\n**Resist the urge!**\n\n## Worth the struggle \n\nAdopt an investment mindset and remember that the little extra time invested in finding good names early on will pay dividends in the long run by reducing the accumulation of complexity in the system.\n\n**The more you do it, the easier it will get!**\n\nAnd, after a while, you won't even need to think long and hard to come up with a good name. You will instinctively think of one.\n\n# Further Reading {.smaller}\n\nFor a more detailed discussion about how to name things, see the following references.\n\n## References {.smaller}\n\n- McConnell, S. (2004). *Code Complete*. Microsoft Press. (**pp. 259-290**)\n\n- Boswell, D., & Foucher, T. (2011). *The Art of Readable Code*. O'Reilly Media, Inc. (**pp. 7-31**)\n\n- Martin, R. C. (2009). *Clean Code*. Pearson Education. (**pp. 17-52**)\n\n- Ousterhout, J. K. (2018). *A Philosophy of Software Design*. Palo Alto: Yaknyam Press. (**pp. 121-129**)\n\n- Goodliffe, P. (2007). *Code Craft*.  No Starch Press. (**pp. 39-56**)\n\n- Padolsey, J. (2020). *Clean Code in JavaScript*. Packt Publishing. (**pp. 93-111**)\n\n- Thomas, D., & Hunt, A. (2019). *The Pragmatic Programmer*. Addison-Wesley Professional. (**pp. 238-242**)\n\n- [Ottinger's Rules for Variable and Class Naming](https://exelearning.org/wiki/OttingersNaming/){target=\"_blank\"}\n\n- For a good example of organizational naming guidelines, see [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#Naming){target=\"_blank\"}.\n\n# For more\n\nIf you are interested in good programming and software development practices, check out my other [slide decks](https://sites.google.com/site/indrajeetspatilmorality/presentations){target=\"_blank\"}.\n\n# Find me at...\n\n{{< fa brands twitter >}} [Twitter](http://twitter.com/patilindrajeets){target=\"_blank\"}\n\n{{< fa brands linkedin >}} [LikedIn](https://www.linkedin.com/in/indrajeet-patil-397865174/){target=\"_blank\"}\n\n{{< fa brands github >}} [GitHub](http://github.com/IndrajeetPatil){target=\"_blank\"}\n\n{{< fa solid link >}} [Website](https://sites.google.com/site/indrajeetspatilmorality/){target=\"_blank\"}\n\n{{< fa solid envelope >}} [E-mail](mailto:patilindrajeet.science@gmail.com){target=\"_blank\"}\n\n# Thank You \n\nAnd Happy Naming! 😊\n\n## Session information {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info(include_base = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.0 (2024-04-24)\n os       Ubuntu 22.04.4 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  C.UTF-8\n ctype    C.UTF-8\n tz       UTC\n date     2024-05-05\n pandoc   3.1.13 @ /opt/hostedtoolcache/pandoc/3.1.13/x64/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n base        * 4.4.0   2024-04-24 [3] local\n cli           3.6.2   2023-12-11 [1] RSPM\n compiler      4.4.0   2024-04-24 [3] local\n datasets    * 4.4.0   2024-04-24 [3] local\n digest        0.6.35  2024-03-11 [1] RSPM\n evaluate      0.23    2023-11-01 [1] RSPM\n fastmap       1.1.1   2023-02-24 [1] RSPM\n graphics    * 4.4.0   2024-04-24 [3] local\n grDevices   * 4.4.0   2024-04-24 [3] local\n grid          4.4.0   2024-04-24 [3] local\n htmltools     0.5.8.1 2024-04-04 [1] RSPM\n jsonlite      1.8.8   2023-12-04 [1] RSPM\n knitr         1.46    2024-04-06 [1] RSPM\n lattice       0.22-6  2024-03-20 [3] CRAN (R 4.4.0)\n Matrix        1.7-0   2024-03-22 [3] CRAN (R 4.4.0)\n methods     * 4.4.0   2024-04-24 [3] local\n png           0.1-8   2022-11-29 [1] RSPM\n Rcpp          1.0.12  2024-01-09 [1] RSPM\n reticulate    1.36.1  2024-04-22 [1] RSPM\n rlang         1.1.3   2024-01-10 [1] RSPM\n rmarkdown     2.26    2024-03-05 [1] RSPM\n sessioninfo   1.2.2   2021-12-06 [1] any (@1.2.2)\n stats       * 4.4.0   2024-04-24 [3] local\n tools         4.4.0   2024-04-24 [3] local\n utils       * 4.4.0   2024-04-24 [3] local\n xfun          0.43    2024-03-25 [1] RSPM\n yaml          2.3.8   2023-12-11 [1] RSPM\n\n [1] /home/runner/work/_temp/Library\n [2] /opt/R/4.4.0/lib/R/site-library\n [3] /opt/R/4.4.0/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
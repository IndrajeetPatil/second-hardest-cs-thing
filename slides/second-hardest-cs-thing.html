<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Dealing with second hardest thing in Computer Science</title>
    <meta charset="utf-8" />
    <meta name="author" content="Indrajeet Patil" />
    <meta name="date" content="2022-04-12" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Dealing with second hardest thing in Computer Science
## <br/>How to name things
### Indrajeet Patil
### esqLABS
### 2022-04-12

---




---

layout: false

class: inverse, center, middle

## "There are only two hard things in Computer Science: &lt;/br&gt;cache invalidation and naming things."&lt;/br&gt;
### - Phil Karlton

---

layout: false

class: inverse, center, middle

## The following advice about naming applies to various objects (variables, functions, classes, etc.)!

## It is deliberately language-agnostic.

---

## Guiding Principle: **Names are a form of abstraction**

&gt; [T]he best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important.
&gt; 
&gt; -- Jonh Ousterhout

## Importance: **Names are at the core of software design** 

If you can't find a good name for a variable or a function that provides the right abstraction for the underlying object, it is possible that the underlying object doesn't have a clear design.

## Properties: **Good names are precise and consistent**

In what follows, we will see some advice on how to satisfy these properties.

---

layout: false

class: inverse, center, middle

# Names should convey a lot of information

---

## Good names are a form of documentation.

How good a name is can be assessed by how detailed the accompanying comment needs to be.

For example, this has neither good function nor parameter name, and you can tell that from how much work the comments are doing:


```cpp
// function to convert temperature from Fahrenheit to Celsius scale
// temp is the temperature in Fahrenheit
double unitCoverter(double temp)
```

Contrast it with (we don't even need a comment here!):


```cpp
double fahrenheitToCelsius(double fahrenheit)
```

**Good names rarely require readers to read the documentation to understand what they represent.**

---

## Avoid generic names.

Generic names don't provide much information about the values or the purpose of the entity that the name is attached to.

For example, 


```python
distance() # too generic 
euclidean_distance() # more specific and informative
```

*Case study*

The parameter [`N`](https://en.cppreference.com/w/cpp/container/array) in `std::array` definition is too generic.


```cpp
template&lt;
    class T,
    std::size_t N
&gt; struct array;
```

A better name would have been `size`.

**Generic names compromise code readability because they provide little information.**

---

## Follow conventions if you use generic names.

Sometimes using generic names may actually improve code readability. But, in such cases, it is vital to follow the conventions!

For example, using `j` for outer and `i` for inner loop is confusing!


```javascript
  for (let j = 0; j &lt; arr.length; j++) {
    for (let i = 0; i &lt; arr[i].length; i++) {
      
    }
  }
```

Similarly, `temp` shouldn't be used to store objects that are not temporary.


```r
sumXY &lt;- function(x, y) {
  temp = x + y
  return(temp)
}
```

etc.

**Don't violate reader assumptions about what generic names represent.**

---

layout: false

class: inverse, center, middle

# Naming schema should be consistent

---

layout: false

class: inverse, center, middle

## Case study: *ggplot2*

*ggplot2* is a [plotting framework](https://ggplot2.tidyverse.org/) in R. 

Quite admirably, it anticipates both **British** and **American** English spellings. 

But does it do it consistently?

---

## Function names

Both forms of spellings are supported.


```r
# works
guide_colorbar(...)

# this works as well
guide_colourbar(...)
```

## Function parameters

Both forms of spellings are supported.


```r
# works
aes(color = my_variable)

# this works as well
aes(colour = my_variable)
```

---

## Function names *and* parameters 

A user has now come to believe that *ggplot2* supports British and American spellings for both function names and parameters.

And, since they prefer American spellings, they do this:


```r
guide_colorbar(ticks.color = "black")
```

**That won't work!!**

Because both functions support **only** the British spelling of parameters:


```r
guide_colourbar(ticks.colour = "black")
guide_colorbar(ticks.colour = "black")
```

This is **inconsistent** and **violates user assumptions** about function and parameter naming schema&lt;sup&gt;*&lt;/sup&gt;.

.footnote[

*This can be a painful source of bug to fix because the function will silently fail.

]

---

layout: false

class: inverse, center, middle

# Find me on...

.font100[

üê¶ [Twitter](http://twitter.com/patilindrajeets)

üíº [LinkedIn](https://www.linkedin.com/in/indrajeet-patil-397865174/)

üíª [GitHub](mailto:patilindrajeet.science@gmail.com)

]

---

layout: false

class: inverse, center, middle

## Code for these slides is available [here](https://github.com/IndrajeetPatil/second-hardest-cs-thing/).

If you have any feedback on these slides, please create issue there.

---

layout: false

class: inverse, center, middle

# The End üëã
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

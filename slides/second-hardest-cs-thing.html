<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>.yellow[Dealing with the Second Hardest Thing in Computer Science]</title>
    <meta charset="utf-8" />
    <meta name="author" content=".yellow[Indrajeet Patil (Software Engineer, esqLABS)]" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link rel="stylesheet" href="second-hardest-cs-thing.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# .yellow[Dealing with the Second Hardest Thing in Computer Science]</br></br></br>
### </br></br></br></br></br></br></br></br>.yellow[Indrajeet Patil (Software Engineer, esqLABS)]

---




layout: false

class: inverse, center, middle

## "There are only two hard things in Computer Science: &lt;/br&gt;cache invalidation and naming things."&lt;/br&gt;
### - Phil Karlton

---

layout: false

class: inverse, center, middle

## The following advice about naming applies to various objects (variables, functions, classes, etc.)!

## It is deliberately language-agnostic.

---

## Guiding Principle: **Names are a form of abstraction**

&gt; "[T]he best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important."
&gt; 
&gt; \- Jonh Ousterhout

--

## Importance: **Names are at the core of software design** 

If you can't find a name that provides the right abstraction for the underlying object, it is possible that the underlying object doesn't have a clear design.

--

## Properties: **Good names are precise and consistent**

It is difficult to miss out on critical information about the object or to misinterpret the underlying representation based on its name

---

layout: false

class: inverse, center, middle

# "The beginning of wisdom is to call things by their proper name."&lt;/br&gt;
## - Confucius

---

## Good names are a form of documentation.

How good a name is can be assessed by how detailed the accompanying comments need to be.

--

For example, this has neither good function nor parameter name, and you can tell that from how much work the comments are doing:


```cpp
// function to convert temperature from Fahrenheit to Celsius scale
// temp is the temperature in Fahrenheit
double unitCoverter(double temp)
```

--

Contrast it with (we don't even need a comment here!):


```cpp
double fahrenheitToCelsius(double tempFahrenheit)
```

--

.content-box-blue[
**Good names rarely require readers to read the documentation to understand what they represent.**
]

---

## Generic names should be avoided.

Generic names don't provide much information about the values or the purpose of the entity they represent.

For example, 


```r
count # too generic
character_count # more informative

distance() # too generic 
euclidean_distance() # more specific and informative
```

.content-box-blue[
**Generic names compromise code readability because they provide little information.**
]

---

## Conventions should be followed for generic names.

Sometimes using generic names may actually improve code readability. But, in such cases, it is vital to follow language or domain conventions.

For example, using `j` for outermost and `i` for nested loop is confusing!


```js
  for (let j = 0; j &lt; arr.length; j++) {
    for (let i = 0; i &lt; arr[j].length; i++) {
      
    }
  }
```

Similarly,

- `temp` shouldn't be used to store objects that are not temporary
- `retVal` shouldn't be used for objects not returned from function
- etc.

.content-box-blue[
**Don't violate reader assumptions about what generic names represent.**
]

---

## Names should be consistent.

Consistent names reduce cognitive burden on the readers because if they encounter a name in one context, they can safely reuse that knowledge in another context.

For example, these names are inconsistent since the reader can't safely assume the name `size` means the same thing throughout the program.


```c
// context-1: `size` stands for number of memory bytes
{
  size = sizeof(x);
}

// context-2: `size` stands for number of elements
{
  size = strlen(a);
}
```

.content-box-blue[
**Allow users to make safe assumptions about what the names represent across different scopes/contexts.**
]

---

### Unnecessary words from names should be removed...

.pull-left[

```r
# okay 
convert_to_string()
createPlotHistogram()
fileObject
strName # Hungarian notation
```
]

.pull-right[


```r
# better 
to_string()
plotHistogram()
file
name
```

]

&lt;/br&gt;

--

### but important details should be kept!

.pull-left[


```r
# okay 
child_height
password
id
address
```

]

.pull-right[


```r
# better 
child_height_cm
plaintext_password
hex_id
ip_address
```

]

.content-box-blue[
**If some information is critical to know, it should be part of the name.**
]

---

## Names should be precise but not *too* long.

How precise the name should be is a **subjective decision**. You can typically find a middle ground.

--

Consider the following variable names:


```r
# not ideal - too imprecise
d
# okay - can use more precision
days 

# good - middle ground
days_since_last_accident 

# not ideal - unnecessarily precise
days_since_last_accident_floor_4_lab_23 

...
```

--

.content-box-blue[
**Don't go too far with making names precise.**
]

---

## Names should be difficult to misinterpret.

Try your best to misinterpret candidate names and see if you succeed.

--

Example: Here is a GUI text editor class method to get position of a character


```cpp
std::tuple&lt;int, int&gt; getCharPosition(int x, int y)
```

--

How I interpret it: 

&gt; `x` and `y` refer to pixel positions for a character.

--

How it's meant to be interpreted:

&gt; `x` and `y` refer to line of text and character position in that line.

--

You can avoid such misinterpretation with better names:


```cpp
std::tuple&lt;int, int&gt; getCharPosition(int lineIndex, int charIndex)
```

--

.content-box-blue[
**Making names as precise and unambiguous as possible leaves little room for misconstrual.**
]

---

## Names should be easily searchable.

While naming things, always ask yourself how easy it would be to replace the chosen name with a different name in the future.

--

For example, this plotting function uses identifier `p` to represent plot.


```r
plotScatter &lt;- function() {
  p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()
  p &lt;- p + labs(title = "my first scatter plot")
  p
}
```

In future, if you wanted to rename it, it won't be easy either to search or to replace it in the codebase.

Instead, if you use `scatter_plot`, both search and replace operations will be a piece of cake.

--

.content-box-blue[
**Choose names that can be searched and, if the need arises, replaced.**
]

---

## Names should honor the culture.

The names should respect the conventions adopted in a given programming language, domain of knowledge, project, organization, etc.

--

For example, C++ convention is to use PascalCase for class names and lowerCamel case for methods. The following code violates these conventions and compromises readability:


```cpp
class playerEntity
{
public:
    double height;
    set_height(double height) : height{height} { }
};
```

--

.content-box-blue[
**Don't break conventions unless other guidelines require overriding them for consistency.**
]

---

## Name Booleans with extra care.

Names for Boolean variables or functions should make clear what true and false means. This can be done using prefixes (**is**, **has**, **can**, etc.).

.pull-left[


```r
# not great
if (child) {
  if (parentSupervision) {
    watchHorrorMovie &lt;- TRUE
  }
}
```

]

.pull-right[


```r
# better
if (isChild) {
  if (hasParentSupervision) {
    canWatchHorrorMovie &lt;- TRUE
  }
}
```

]

&lt;/br&gt;

Prefer not to use negated terms for Booleans since they are harder to process.

.pull-left[


```r
# not great
disable_firewall = FALSE
```

]

.pull-right[


```r
# better
enable_firewall = TRUE
```

]

---

## Formatting names can provide additional information.

Having different name formats for different entities makes the code easier to read because it **acts like syntax highlighting**.

For example, here is an example of formatting conventions (adopted in [OSP organization](https://github.com/Open-Systems-Pharmacology/Suite/blob/develop/CODING_STANDARDS.md)):

&lt;img src="images/osp_naming.png" width="3232" /&gt;


---

## Names should be kept up-to-date.

To resist software entropy, not only should you name entities properly, but you should also rename them to keep up with the new developments.

--

Otherwise, names will become something worse than meaningless or confusing: **misleading**.

For example, let's say your class has `$getMeans()` method. 

- In its initial implementation, it used to return *precomputed* mean values. 
- In its current implementation, it *computes* the means on the fly. 

Therefore, it is misleading to continue to call it a getter method, and it should be renamed to `$computeMeans()`.

--

.content-box-blue[
**Keep an eye out for API changes that make names in your codebase misleading.**
]

---

## Names should be pronounceable.

This is probably the weakest of the requirements, but one can't deny the ease of communication when names are pronounceable.

--

If you are writing a function to generate a time-stamp, discussing following function verbally would be challenging.


```r
# generate year month date hour minute second
genymdhms()
```

This is a much better (and pronounceable) alternative:


```r
generateTimeStamp()
```

---

# Use consistent lexicon in a project.

Once you settle down on a mapping from an abstraction to a name, use it consistently *throughout the codebase*.

E.g., the same abstraction is mapped to different names across R6 classes:


```cpp
DebitCardAccount$new()$fetch_expenditure()
CreditCardAccount$new()$get_expenditure()
```

Across classes, this method should either be named `$get_expenditure()` or `$fetch_expenditure()`, but not both.

.content-box-blue[
**Consistency of naming conventions should be respected at the codebase level, not just for short scopes.**
]

---

layout: false

class: inverse, center, middle

# Case studies

### Looking at names in the wild that violate presented guidelines.

This is **not** to be taken as criticisms but as real-life learning opportunities to drive home the importance of these guidelines.

---

## Violation: Breaking (domain) conventions

R is a programming language for statistical computing, and function names can be expected to respect the domain conventions.

--

Statistical distributions can be characterized centrality measures, like mean, median, mode, etc., and R has functions with names that wouldn't surprise you, except one:


```r
mean(c(1, 2, 3, 4)) # works
median(c(1, 2, 3, 4)) # works
*mode(c(1, 2, 3, 4)) # error!
```

The `mode()` function actually returns the storage mode of an R object!

--

This function could have been named (e.g.) `storageMode()`, which is more precise and doesn't break domain-specific conventions.

---

## Violation: Generic name

The parameter `N` in `std::array` [definition]((https://en.cppreference.com/w/cpp/container/array)) is too generic.


```cpp
template&lt;
    class T,
*   std::size_t N
&gt; struct array;
```

`size` is a bit better but still leaves room for misunderstanding: 
&gt; "Does it mean length or memory bytes?"

--

`numberOfElements` is more precise and unmistakable:


```cpp
template&lt;
    class T,
*   std::size_t numberOfElements
&gt; struct array;
```

---

layout: false

class: inverse, center, middle

## Violation: Inconsistency in naming schema

*ggplot2* is a [plotting framework](https://ggplot2.tidyverse.org/) in R. 

Quite admirably, it accepts both **British** and **American** English spellings. 

But does it do so *consistently*?

---

## Function names

Both forms of spellings are supported.


```r
# works
guide_colorbar(...)

# this works as well
guide_colourbar(...)
```

--

## Function parameters

Both forms of spellings are supported.


```r
# works
aes(color = my_variable)

# this works as well!
aes(colour = my_variable)
```

---

## Function names *and* parameters 

A user has now come to believe that *ggplot2* supports British and American spellings for both function names *and* parameters.

And, since they prefer American spellings, they do this:


```r
guide_colorbar(ticks.color = "black")
```

--

**That won't work!**

Both functions support **only** the British spelling of parameters:


```r
guide_colourbar(ticks.colour = "black")
guide_colorbar(ticks.colour = "black")
```

--

This is **inconsistent** and **violates user's mental model** about function and parameter naming schema&lt;sup&gt;*&lt;/sup&gt;.

.footnote[

*This can be a painful source of bugs because the function will fail silently.

]

---

## Violation: Room for misunderstanding

In Python, [`filter()`](https://www.w3schools.com/python/ref_func_filter.asp) can be used to apply a function to an iterable.


```python
list(filter(lambda x: x &gt; 0, [-1, 1]))
```

But `filter` is an ambiguous work:
- It could mean to pick out elements that pass a condition (what *remains after filtering*), or
- it could mean to pick out elements that need to be removed (what *is filtered*). 

Imagine you've never used this function before. Can you predict if it will return `1` or `-1`?

--

It returns `1`, so the intent is to pick out the elements that pass the condition. &lt;/br&gt;
In this case, **`keep()`** would've be a better name.

Had the intent been to find elements to remove, **`discard()`** would've be a better name.

---

layout: false

class: inverse, center, middle

# etc.

### It is easy to find such violations, but, whenever you encounter one, make it a personal exercise to come up with a better name.

---

layout: false

class: inverse, center, middle

# Challenges

---

## Worth the struggle

--

Initially, you may struggle to find good names and settle down for the first serviceable name that pops into your head.

**Resist the urge!**

--

Adopt an investment mindset and remember that the little extra time invested in finding good names early on will pay dividends in the long run by reducing accumulation of complexity in the system.

--

**The more you do it, the easier it will get!**

And, after a while, you won't even need to think long and hard to come up with a good name. You will instinctively think of one!

---

layout: false

class: inverse, center, middle

# Benefits of naming things well

---

## "What's in a name?" Well, everthing!

--

- Trying to find good names forces you to detach from the problem-solving mindset and to **focus on the bigger picture** that motivates this change. This is critical for thoughtful software design.

--

- Searching for precise names requires clarity, and seeking such clarity **improves your own understanding** of the code.

--

- Naming precisely and consistently **reduce ambiguities and misunderstandings**, which reduce the possibility of bugs.

--

- Good names **reduce the need for documentation**.

--

- Good names **reduce cognitive overload** for the developers and make the code more maintainable.

---

# Further Reading

For more detailed account of how to name things, check out following references. 
The **page numbers** in parentheses point to the relevant portions.

- Boswell, D., &amp; Foucher, T. (2011). *The Art of Readable Code*. O'Reilly Media, Inc. (**pp. 7-31**)

- Ousterhout, J. K. (2018). *A Philosophy of Software Design*. Palo Alto: Yaknyam Press. (**pp. 121-129**)

- McConnell, S. (2004). *Code Complete*. Microsoft Press. (**pp. 259-290**)

- Martin, R. C. (2009). *Clean Code*. Pearson Education.(**pp. 17-30**)

- Thomas, D., &amp; Hunt, A. (2019). *The Pragmatic Programmer*. Addison-Wesley Professional. (**pp. 238-242**)

For a good example of organizational naming guidelines, see:

- [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#Naming)


---

layout: false

class: inverse, center, middle

# Find me on...

.font100[

🐦 [Twitter](http://twitter.com/patilindrajeets)

💼 [LinkedIn](https://www.linkedin.com/in/indrajeet-patil-397865174/)

💻 [GitHub](mailto:patilindrajeet.science@gmail.com)

]

---

layout: false

class: inverse, center, middle

## Source code for these slides is available [here](https://github.com/IndrajeetPatil/second-hardest-cs-thing/).

If you have any feedback on these slides, please create issue there.

---

layout: false

class: inverse, center, middle

# The End 👋
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "monokai",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
